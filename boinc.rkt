#lang racket

(require racket/include xml)
(require "boinc-xml.rkt")
(require "boinc-structs.rkt")
(require "parse.rkt")

(define (xexpr-get-document-element xml-string)
  (xml->xexpr (document-element (read-xml (open-input-string xml-string)))))

(define (sublists-only element)
  (if (and (list? element) (not (empty? element)))
      (filter (lambda (x)
                (and (list? x)
                     (not (empty? x))))
              (cddr element))
      (list)))

(define (get-node stats stat-name)
  (if (empty? stats)
      (list)
      (if (or (empty? (first stats)) (not (list? (first stats))))
          (if (empty? (rest stats))
              (list)
              (get-node (rest stats) stat-name))
          (if (eq? (first (first stats)) stat-name)
              (first stats)
              (if (empty? (rest stats))
                  (list)
                  (get-node (rest stats) stat-name))))))

(define (get-nodes stats stat-name [nodes (list)])  
  (if (eq? (first (first stats)) stat-name)
      (if (empty? (rest stats))
          (append nodes (list (first stats)))
          (get-nodes (rest stats) stat-name (append nodes (list (first stats)))))
      (if (empty? (rest stats))
          nodes
          (get-nodes (rest stats) stat-name nodes))))

(define (get-stat-value stats stat-name)
  (let ((stat-entry (get-node stats stat-name)))
    (if (list? stat-entry)
        (if (< (length stat-entry) 3) "" (third stat-entry))
        "")))

(define (get-main-node f node-id)
  (let* ((root-xml (xexpr-get-document-element (f)))
         (main-node (sublists-only (get-node (cddr root-xml) node-id))))
    main-node))

(define (accumulate-element-list elements construct-func)

  (define (make-get-stat-value elements)
    (lambda (x) (get-stat-value elements x)))

  (define (make-get-stat-element elements)
    (lambda (x) (sublists-only (get-node elements x))))
  
  (define (make-get-child-nodes elements)
    (lambda (x) (get-nodes elements x)))
  
  (define (do-it elements [output (list)])
    (if (empty? elements)
        output
        (let* ((this-element (sublists-only (first elements)))
               (gs (make-get-stat-value this-element))
               (gse (make-get-stat-element this-element))
               (gns (make-get-child-nodes this-element))
               (new-output (append output (list (construct-func this-element gs gse gns)))))
          (if (empty? (rest elements))
              new-output
              (do-it (rest elements) new-output)))))
  (do-it elements))

(define (get-state)
           
  (let* ((state-xml (xexpr-get-document-element (get-state-xml)))
         (client-state (cddr (get-node (cddr state-xml) 'client_state)))
         (gse (lambda (x) (sublists-only (get-node client-state x))))
         (gses (lambda (x) (third (get-node client-state x))))
         (gns (lambda (x) (get-nodes client-state x))))
    (get-state-result (parse-host-info (gse 'host_info))
                      (parse-net-stats (gse 'net_stats))
                      (parse-time-stats (gse 'time_stats))
                      (parse-projects (gns 'project))
                      (parse-workunits (gns 'workunit)) 
                      (parse-results (gns 'result))     
                      (gses 'platform_name)
                      (gses 'core_client_major_version)
                      (gses 'core_client_minor_version)
                      (gses 'core_client_release)
                      (gses 'executing_as_daemon)
                      (gses 'platform) 
                      (parse-global-preferences (gse 'global_preferences))
                      (parse-app (gns 'app))
                      (parse-app-version (gns 'app_version)))))

(define (get-host-info)
    (parse-host-info (get-main-node get-host-info-xml 'host_info)))

(define (get-disk-usage)
  (let* ((disk-usage-node (get-main-node get-disk-usage-xml 'disk_usage_summary))
         (gs (lambda (x) (get-stat-value disk-usage-node x)))
         (gns (lambda (x) (get-nodes disk-usage-node x)))
         (f (lambda (x gs gse gns)
            (disk-usage-project (gs 'master_url)
                                (gs 'disk_usage)))))
    (disk-usage (gs 'd_total)
                (gs 'd_free)
                (gs 'd_boinc)
                (gs 'd_allowed)
                (accumulate-element-list (gns 'project) f))))

(define (get-cc-status)
  (let* ((cc-status-node (get-main-node get-cc-status-xml 'cc_status))
         (gs (lambda (x) (get-stat-value cc-status-node x))))
    (cc-status
     (gs 'network_status)
     (gs 'ams_password_error)
     (gs 'task_suspend_reason)
     (gs 'task_mode)
     (gs 'task_mode_perm)
     (gs 'task_mode_delay)
     (gs 'gpu_suspend_reason)
     (gs 'gpu_mode)
     (gs 'gpu_mode_perm)
     (gs 'gpu_mode_delay)
     (gs 'network_suspend_reason)
     (gs 'network_mode)
     (gs 'network_mode_perm)
     (gs 'network_mode_delay)
     (gs 'disallow_attach)
     (gs 'simple_gui_only)
     (gs 'max_event_log_lines))))

(define (get-project-status)
    (parse-projects (get-main-node get-project-status-xml 'projects)))
         
(define (get-results [active-only #f])
    (parse-results (get-main-node (lambda () (get-results-xml active-only)) 'results)))

(define (get-daily-transfer-history)

  (define (parse-daily-transfer-history nodes [output (list)])
    (if (empty? nodes)
        (list)
        (let* ((this-day (sublists-only (first nodes)))
               (gs (lambda (x) (get-stat-value this-day x)))               
               (dt (daily-transfer (gs 'when)
                                   (gs 'up)
                                   (gs 'down)))
               (new-output (append output (list dt))))
          
          (if (empty? (rest nodes))
              new-output
              (parse-daily-transfer-history (rest nodes) new-output)))))
          
  (let* ((root-xml (xexpr-get-document-element (get-daily-transfer-history-xml)))
         (main-node (sublists-only (get-node (cddr root-xml) 'daily_xfers)))
         (gns (lambda (x) (get-nodes main-node x))))
    (parse-daily-transfer-history (gns 'dx))))

